.center{
    text-align: center;
    color: black;
}


/* Це домашне завдання урок 8 
.foto img {
    width: 200px;
    height: 200px;
    margin: 20px;
    padding: 25px;
    border-radius: 50px;
    background: url(images/unsplash.jpg);
    background-size: cover;
    position: absolute;
    top: 10px;
    right: 50px;
    display: none;
    
}

*/



/* Це домашне завдання урок #18 */

/* Визначення стилів кнопки */
.button {

    /* Колір фону кнопки */
    background-color: green;
  
    /* Колір тексту кнопки */
    color: white;
  
    /* Відступи навколо тексту кнопки */
    padding: 20px 40px 20px 40px;
  
    /* Відсутність рамки навколо кнопки */
    border: none;
  
    /* Розмір шрифту тексту кнопки */
    font-size: 16px;
  
    /* Обрізання кутів кнопки */
    border-radius: 10px;
  
    /* Розташування кнопки в рядку */
    display: inline-block;
  
    /* Анімація трансформації та кольору кнопки */
    transition: transform 0.2s, background-color 0.2s;
  
    /* Курсор кнопки */
    cursor: pointer;
  }
  

/* 
Урок №37
Використання властивості pointer-events
 для контролю подій миші на елементах.
Домашне завдання.
Напишіть код CSS, який використовує властивість pointer-events 
для створення прозорого оверлею, 
що блокує всі події миші від досягнення елементів нижче нього.
 

/* Це код для створення затемнення та модального вікна *

/* Стиль затемнення * 
.overlay {

    /* Позиціонування затемнення: фіксовано *
    position: fixed;
  
    /* Верхній край затемнення: 0 пікселів *
    top: 0;
  
    /* Лівий край затемнення: 0 пікселів *
    left: 0;
  
    /* Ширина затемнення: 100% ширини вікна *
    width: 100%;
  
    /* Висота затемнення: 100% висоти вікна *
    height: 100%;
  
    /* Колір фону затемнення: чорний, непрозорість 50% *
    background-color: rgb(0, 0, 0, 0.5);
  
    /* Дозволяє користувачеві взаємодіяти з елементами під затемненням *
    pointer-events: all;
  }
  
  /* Стиль модального вікна *
  .modal {
  
    /* Позиціонування модального вікна: фіксовано *
    position: fixed;
  
    /* Верхній край модального вікна: 50% від висоти вікна *
    top: 50%;
  
    /* Лівий край модального вікна: 50% від ширини вікна *
    left: 50%;
  
    /* Ширина модального вікна: 400 пікселів *
    width: 400px;
  
    /* Висота модального вікна: 300 пікселів *
    height: 300px;
  
    /* Колір фону модального вікна: білий *
    background-color: white;
  
    /* Перетворення модального вікна: центрування по горизонталі та вертикалі *
    transform: translate(-50%, -50%);
  }
  
*/


/*
.button:hover{
    padding: 20px 60px;
    background-color: yellow;
    transform: scale(1.5);
}
*/


/*Використання псевдокласів :active та :focus 
для стилювання активних та фокусованих елементів Урок №29*/

/* Зміна фонового кольору кнопки при активному натисканні */
.button:active {
    background-color: darkgreen;
}

/* Домашне завдання CSS урок #29
Напишіть CSS правило, яке змінює колір тексту у полі введення на зелений,
 коли користувач клікає всередині цього поля (елемент у фокусі).*/
/* Застосування правила до елементів input, які отримали фокус */
/* Коли елемент input знаходиться у фокусі (коли користувач клікає на поле введення) */
input:focus {
    /* Встановлює товщину та колір межі для підкреслення поля введення */
    border: 2px solid royalblue;
    
    /* Забороняє стандартний контур (виділення) для вибраного елемента */
    outline: none;
    
    /* Змінює колір тексту у введенні, коли воно знаходиться у фокусі */
    color: green;
}




body{
    
    /*background-image: url("images/background1.jpg");*/
    background-size: cover;
    
}

/* Практичне завдання CSS урок #15*/
.backgraund{
    background-color: rgb(219, 232, 219);
    background-image: url('images/example.jpg');
    background-repeat: no-repeat;
    border-radius: 35px;
    background-position: right;
    background-size: cover;
    box-shadow: 5px 10px blue
          inset -3px -5px red;
}

/* Практичне завдання CSS урок #14*/
p{
    font-family: Arial, sans-serif;
    font-size: 16px;
    font-style: italic;
    font-weight: 700;
    line-height: 1.6;
}

.center{
    text-align: justify;
    padding: 15px;
}


/* Практичне завдання CSS урок #15*/
.title{
    text-transform: capitalize;
    text-align: center;
    text-decoration: underline dashed red;
}


/* Практичне завдання CSS урок #17 */
/* Цей код визначає стилі для елементів <p> 
при наведенні на них та hover ефект анімації при
наведенні мишки на текст *

p:hover {

    /* Вирівнює текст по ширині *
    text-align: justify;
  
    /* Додає до тексту відступ 15 пікселів *
    padding: 15px;
  
    /* Робить колір тексту синім *
    color: blue;
  }
  */



/* Практичне завдання CSS урок #18*/
.container {
    display: flex;
    flex-direction: row;
    justify-content: center;
    align-items: center; 
    flex-wrap: wrap;
}

.box{
    width: 30%; 
    float: left; 
    border-radius: 35px; 
    padding: 10px;
    height: 1100px;
    overflow-x: hidden;
    overflow-y: auto;
    
}
/* Практичне завдання CSS урок #18*/

/* Практичне завдання CSS урок #20*/

.container {
    display: flex;
    flex-wrap: wrap;
    justify-content: space-between;
}

.box {
    width: calc(30% - 20px); /* Изменено на 30% для трех колонок */
    margin: 10px;
    border-radius: 35px;
    padding: 10px;
    height: 1100px;
    overflow-x: hidden;
    overflow-y: auto;
    box-sizing: border-box;
}

@media (max-width: 675px) {
    .box {
        width: 100%;
        float: none;
    }
}

/* Практичне завдання CSS урок #20*/ 


@media  (max-width: 600px) {
    .box {
        font-size: 18px;
    }
}


@media (min-width: 600px) and (max-width: 900px) {
    .box {
        font-size: 20px;
    }
}


@media (min-width: 901px) {
    .box {
        font-size: 22px;
    }
}

/* Практичне завдання CSS урок #21
.ball {
    width: 100px;
    height: 100px;
    background-color: blue;
    border-radius: 10%;
}

.ball:hover {
    transform: scale(2) rotate(90deg);
}
*/


/* Практичне завдання CSS урок #22
Використання правила @keyframes для 
створення користувацьких анімацій*/
@keyframes fadeIn{
    /*Початкові стилі*/
    0% {opacity: 0;}
    
    /*Середні стилі*/
    50% {opacity: 1;}
    
    /*Кінцеві стилі*/
    100% {opacity: 3;}
}
/*Застосовуємо @keyframes для table*/
table{
    /*Підключаєм fadeIn*/
    animation-name: fadeIn;
    
    /*Час відображення*/
    animation-duration: 5s;
}

/*Ця анімація bounce моделює ефект відскоку
/*Створюємо м`яч з класом ball*
.ball{
/*Задаємо ширену та висоту*
    width: 150px;
    height: 150px;

    /*Задаємо колір*
    background-color: blue;

    /*Ребемо  м`яч круглим*
    border-radius: 50%;

    /*Задаємо ім`я*
    animation-name: bounce;

    /*Задаємо 2 секунди для анімації*
    animation-duration: 2s;

    /*Анімація буде повторюватис не скінчено*
    animation-iteration-count: infinite;

    /*Змінюємо напрямок анімації*
    animation-direction: alternate;

    /*Гарантує що анімація зберігає свфй стан після завершення, 
    це буде застосованно як що 
    відключити властивість animation-iteration-count: infinite*
    animation-fill-mode: forwards;

    /*Підключаємо анімацію кольору з назваю colorChange*
    animation: colorChange 5s infinite;
}*/

@keyframes bounce {
    /*Елемент починає зі своєї початкової позиції*/
    0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
    
    /*переміщується вгору на 30 пікселів*/
    40% { transform: translateY(-30px); }
    
    /*потім трохи опускається і, нарешті,
повертається до своєї вихідної позиції.*/
    60% { transform: translateY(-15px); }
}

/*Ця анімація bounce моделює ефект зміни кольору*/
/* Визначаємо анімаційний ключовий фрейм colorChange. */
@keyframes colorChange {
    /* Початковий стан (0%) - фон червоний. */
    0% { background-color: red; }

    /* Стан на середині анімації (50%) - фон стає синім. */
    50% { background-color: blue; }

    /* Кінцевий стан (100%) - фон стає зеленим. */
    100% { background-color: green; }
}

/* Домашне завдання CSS урок #22 
   Створіть код для анімації, 
   яка змінює колір тексту елемента з чорного 
   на білий протягом 4 секунд*/
   .animation {
    /* Задаємо ім'я анімації, яке визначене нижче */
    animation-name: animationColor;
    
    /* Тривалість анімації - 4 секунди */
    animation-duration: 4s;

    /* Кількість повторень анімації (безкінечно в даному випадку) */
    animation-iteration-count: infinite;
}

/* Описуємо анімаційний ключовий кадр */
@keyframes animationColor {
    /* Початковий стан (0%) - колір тексту чорний */
    0% {
        color: black;
    }
    
    /* Кінцевий стан (100%) - колір тексту білий */
    100% {
        color: white;
    }
}


/*Використання CSS-змінних для створення динамічних стилів Урок №27*/
/*Стоворюємо зміну, :root - означає корінь*/
:root{
    /*надаємо будь яку назву на свій розсуд наприклад --main-color та --secondary-color*/
    --main-color: blue;
    --secondary-color: green;
}

#header{
    /*тут використовуємо змінну var та звертаємось до --main-color, 
    тим саме можемо використовувати одну змінну в різних частинах коду*/
    color: var(--main-color);
}

/* Домашне завдання CSS урок #27 
   Напишіть CSS-правило, яке встановлює змінну 
   --button-border зі значенням "2px solid black" 
   для всіх кнопок у документі, 
   а потім застосуйте цю змінну 
   для властивості border елементів button.*/
/* Кореневий (root) селектор для встановлення CSS-змінних */
:root {
    /* Встановлення значення змінної --button-border на "2px solid black" */
    --button-border: 2px solid black;
}

/* Стилізація всіх кнопок у документі */
button {
    /* Використання значення змінної --button-border для властивості border */
    border: var(--button-border);
    padding: 20px 40px 20px 40px;
}

/*Використання селекторів атрибутів для цілеспрямованого
 вибору елементів з конкретними атрибутами Урок №28*/

 /*робить всі наші посилання в документі синього кольору*/
 a[href]{
    color: blue;
    text-decoration: underline;
 }

 /* Вибір гіперпосилань з атрибутом href, яке має значення  
 початок посилання ^ "mailto" */
a[href^="mailto"] {
    /* Змінює колір тексту на зелений */
    color: green;
    /* Застосовує жирний шрифт */
    font-weight: bold;
}

/* Вибір гіперпосилань (<a>), які мають атрибут href та  
має значення $ закінчуються на ".pdf" */
a[href$=".pdf"] {
    /* Змінює колір тексту на червоний для гіперпосилань на файли PDF */
    color: red;
    /* Застосовує нахилений стиль шрифту для виділення */
    font-style: italic;
}

/* Вибір гіперпосилань (<a>), які мають атрибут target зі значенням "_blank" */
a[target="_blank"] {
    /* Заборона підкреслення для гіперпосилань, 
    які відкриваються у новому вікні або вкладці (_blank) */
    text-decoration: none;
}

/* Вибір гіперпосилань (<a>), які мають атрибут href зі значенням "#top" */
a[href="#top"] {
    /* Зміна кольору тексту на чорний */
    color: black;
    /* Встановлення розміру шрифту на 20 пікселів */
    font-size: 20px;
}

/* Домашне завдання CSS урок #28
   Напишіть CSS-правило, яке застосує стиль до всіх тегів `p` 
   з атрибутом `data-custom`, значення якого починається з "info". 
   У стилі вкажіть колір тексту - синій і відступ знизу - 15px. */

/* Вибір всіх тегів <p> з атрибутом data-custom, 
   значення якого починається з "info" */
   p[data-custom^="info"] {
    /* Зміна коліру тексту на синій */
    color: blue;
    /* Встановлення відступу знизу на 15px */
    margin-bottom: 15px;
}


/* Урок №30 Використання псевдоелементів :before та :after 
   для додавання вмісту до елементів */

/* Застосовуємо курсивний стиль до всіх елементів <p> */
p {
    font-style: italic;
}

/* Додаємо вміст (одинарну лапку) до початку кожного елементу <p> *
p::before {
    content: "'";
    font-size: 3em;
}

/* Додаємо вміст (одинарну лапку) до кінця кожного елементу <p> та позначаємо його абсолютну позицію *
p::after {
    content: "'";
    font-size: 3em;
    position: absolute;
}

/* Додаємо вміст (зображення плей-батону) до початку кожного елементу
 з класом .button це перший варіант
.button::before {
    content: url("images/free-icon-play-button-4980096\ \(2\).png");
    margin-right: 5px;
}*/

/* Додаємо зображення плей-батону до початку кожного елемента з класом .button
Це другий варіант */
.button:before {
    /* Вказуємо, що зображення плей-батону буде взято з шрифту FontAwesome */
    font-family: FontAwesome;
    /* Вказуємо, що зображення плей-батону має код символу "\f007" у шрифті FontAwesome */
    content: "\f007";
    /* Встановлюємо відступ праворуч від зображення плей-батону */
    margin-right: 10px;
  }


  /* Додаємо іконки до посилань */

/* Посилання на зовнішній ресурс */
a[href^="https://"]::after {
    /* Встановлюємо шрифт */
    font-family: FontAwesome;
    /* Додаємо відступ */
    margin-left: 5px;
    /* Встановлюємо вміст */
    content: "\f0c1";
  }
  
  /* Посилання на файл PDF */
  a[href$=".pdf"]::after {
    /* Встановлюємо шрифт */
    font-family: FontAwesome;
    /* Додаємо відступ */
    margin-left: 5px;
    /* Встановлюємо вміст */
    content: "\f1c1";
  }
  

/* Домашне завдання Урок 30
Напишіть CSS-правило з використанням 
псевдоелементу :before для додавання іконки "файл" 
перед кожним посиланням, що вказує на файл з розширенням 
.doc, використовуючи Font Awesome іконку "\f1c2".*/

/* Додаємо іконку "файл" перед посиланнями на файли з розширенням .doc */
a[href$=".doc"]:before {
    /* Встановлюємо шрифт для доданого вмісту */
    font-family: FontAwesome;
    
    /* Додаємо відступ в 10 пікселів праворуч від іконки */
    margin-right: 10px;
    
    /* Встановлюємо вміст псевдоелемента на іконку "файл" з Font Awesome */
    content: "\f1c2";
    
    
  }


  /* Урок №31 
  Використання псевдокласів :first-child та :last-child 
  для цілеспрямованого вибору перших та останніх дітей 
  елемента */

  /* Змінюємо стиль першого абзацу в контейнері */
.container p:first-child {
    /* Знімаємо курсив */
    font-style: normal;
  }
  
  /* Змінюємо колір першої літери заголовка */
  h1::first-letter {
    /* Ставимо колір зеленим */
    color: green;
  }
  
  /* Змінюємо колір і розмір першої літери елемента з класом "big-latter" */
  .big-latter::first-letter {
    /* Ставимо колір зеленим */
    color: green;
    /* Збільшуємо розмір на 3em */
    font-size: 3em;
  }
  
  /* Змінюємо стиль списків */
  li {
    /* Виводимо список в одну лінію */
    display: inline;
    /* Забираємо маркери */
    list-style-type: none;
  }

  
  /* Додаємо кому після кожного елемента списку */
  li::after {
    /* Вміст: кома */
    content: ",";
  }
  
  /* Додаємо "and " перед останнім елементом списку */
  li:last-child::before {
    /* Вміст: "and " */
    content: "and ";
  }
  
  /* Додаємо крапку після останнього елемента списку */
  li:last-child::after {
    /* Вміст: крапка */
    content: ".";
  }



  /* Урок №32
   Використання псевдокласу :nth-child для цілеспрямованого
   вибору конкретних дітей елемента
*/

/* Вибираємо всі парні li */
li:nth-child(even) {
    /* Встановлюємо колір фону на lightblue */
    background-color: lightblue;
  }
  
  /* Вибираємо всі непарні tr */
  tr:nth-child(odd) {
    /* Встановлюємо колір фону на lightgray */
    background-color: lightgray;
  }

  /* Домашнє завдання Урок 32
   Вибір кожного четвертого дитячого елемента 
   у списку `<ul>`, починаючи з третього, 
   та зміна його кольору тексту на червоний
*/
/* Вибираємо всі елементи `li` в `ul`, які мають індекс, який є кратним 4, починаючи з третього елемента */
ul li:nth-child(4n+3) {
    /* Встановлюємо колір тексту на червоний */
    background-color: red;
  }
  


  
/* Домашнє завдання Урок 31
   Напишіть код CSS, який стилізує перший і останній
   абзаци всередині будь-якого `<div>`, встановлюючи для
   першого абзацу колір тексту зелений,
   а для останнього - жовтий.
*/

/* Перший абзац усередині `<div>` */
.pseudoclasses p:first-child {
    /* Встановлюємо колір тексту на зелений */
    color: green;
  }
  
  /* Останній абзац усередині `<div>` */
  .pseudoclasses p:last-child {
    /* Встановлюємо колір тексту на жовтий */
    color: yellow;
  }
  

  /* 
  Урок№33
  Використання функції calc() для виконання 
  обчислень в CSS 
  */

/* Визначення висоти текстового поля */
input {
    /* Висота текстового поля дорівнює 40 пікселів */
    height: 40px;
  
    /* Заокруглення кутів текстового поля */
    border-radius: 10px;
  
    /* Відступ лівого краю текстового поля */
    padding-left: 20px;
  
    /* Ширина текстового поля дорівнює половині ширини вікна браузера мінус 80 пікселів */
    width: calc((100% - 80px) / 2);
  }
  
  
  /*
    Домашне завдання урок №33
    Напишіть CSS-правило, використовуючи функцію calc(), 
    для встановлення висоти елемента, яка буде 
    дорівнювати загальній висоті 
    екрана мінус висота шапки 50px та підвалу 20px.
  */
  
  /* Визначення висоти тіла документа */
  body {
    /* Висота тіла документа дорівнює загальній 
    висоті вікна браузера мінус висота шапки та підвалу */
    height: calc((100% - 50px) - 20)
}



/* Урок №34
Використання властивості filter для застосування 
візуальних ефектів до елементів 
*/
/*
img {
    /* Визначення ширини зображення *
    width: 150px;
  
    /* Додавання відступів до зображення *
    margin: 20px;
    padding: 25px;
  
    /* Заокруглення кутів зображення *
    border-radius: 50px;
  
    /* Розтягування фону зображення на весь елемент *
    background-size: cover;
  
    /* Обрізання фону зображення по межах елемента *
    background-clip: border-box;
  
    /* Зміщення зображення на 50 пікселів зверху *
    top: 50px;
  
    /* Застосування ефекту насиченості до зображення *
    filter: saturate(150%)
  }
  */
  

/*
Домашне завдання урок №34
Створіть CSS правило, яке інвертує 
кольори зображення при наведенні 
курсору та додає плавний 
перехід ефекту протягом 0.6 секунди


img {
    /* Визначення ширини зображення *
    width: 150px;
  
    /* Додавання відступів до зображення *
    margin: 20px;
    padding: 25px;
  
    /* Заокруглення кутів зображення *
    border-radius: 50px;
  
    /* Розтягування фону зображення на весь елемент *
    background-size: cover;
  
    /* Обрізання фону зображення по межах елемента *
    background-clip: border-box;
  
    /* Зміщення зображення на 50 пікселів зверху *
    top: 50px;
  
    /* Застосування ефекту насиченості до зображення *
    filter: saturate(150%);

  }
*/


  /* hover применяємо для наведення мишки *
  img:hover {

    /* Застосування ефекту інверсії кольорів до зображення при наведенні курсору *
    filter: invert(5%);
  
    /* Плавний перехід ефекту протягом 0,6 секунди *
    transition: filter 0.6s;

  }
  */

  /*
  Урок №35
        Використання властивості backdrop-filter 
        для додавання розмиття або інших ефектів 
        до фону елемента
  */

  /*
  .background {

    /* Встановлює зображення як фон блоку *
    background-image: url(images/luke-chesser-3rWagdKBF7U-unsplash.jpg);
  
    /* Визначає ширину та висоту блоку *
    width: 200px;
    height: 200px;
  
    /* Розтягує зображення на весь блок, зберігаючи пропорції *
    background-size: cover;
  
    /* Розміщує вміст усередині блоку по горизонталі *
    display: flex;
  
    /* Вирівнює вміст по нижньому краю блоку *
    align-items: end;

    /* Вирівнює вміст по центру блоку *
    justify-content: center;

    /* Властивість тимчасово приховує елемент від користувача. *
    display: none;
  }
  
  .text {
  
    /* Додає фільтр розмиття до фону, який працює в Chrome та інших WebKit-браузерах *
    -webkit-backdrop-filter: blur(5px);
  
    /* Додає фільтр розмиття до фону, який працює в більшості сучасних браузерів *
    backdrop-filter: blur(5px);
  
    /* Додає відступ до вмісту всередині блоку *
    padding: 15px;
  
    /* Напівпрозорий білий фон тексту *
    background-color: rgb(255 255 255 / 0.3);
  
    /* Заокруглення кутів текстового блоку *
    border-radius: 20px;

    /* Властивість тимчасово приховує елемент від користувача. *
    display: none;
  }
  */
  

  /* 
  Домашне завдання №35
  Напишіть код CSS для div-елемента, який використовує 
  властивість `backdrop-filter` для створення ефекту 
  "стекла" з використанням функції `blur` та `contrast`. 
  Врахуйте сумісність браузера та використовуйте 
  вендорські префікси, якщо це необхідно.
  
  
  .background {

    /* Встановлює зображення як фон блоку *
    background-image: url(images/luke-chesser-3rWagdKBF7U-unsplash.jpg);
  
    /* Визначає ширину та висоту блоку *
    width: 200px;
    height: 200px;
  
    /* Розтягує зображення на весь блок, зберігаючи пропорції *
    background-size: cover;
  
    /* Розміщує вміст усередині блоку по горизонталі *
    display: flex;
  
    /* Вирівнює вміст по нижньому краю блоку *
    align-items: end;
  
    /* Вирівнює вміст по центру блоку *
    justify-content: center;

  }
  */
  /*
  .text {
  
    /* Додає фільтр розмиття до фону, який працює в Chrome та інших WebKit-браузерах *
    -webkit-backdrop-filter: blur(5px);
  
    /* Додає фільтр розмиття до фону, який працює в більшості сучасних браузерів *
    backdrop-filter: blur(5px);

    /* Додає до фону ефект розмиття і підвищення контрасту *
    backdrop-filter: contrast(5px);
  
    /* Додає відступ до вмісту всередині блоку *
    padding: 15px;
  
    /* Напівпрозорий білий фон тексту *
    background-color: rgb(255 255 255 / 0.3);
  
    /* Заокруглення кутів текстового блоку *
    border-radius: 20px;
    
  }
*/
  /*
  Урок №36
  Використання властивості clip-path для створення
  користувацьких форм та вирізів
*

.clipPath {
    /* Визначення ширини зображення *
    width: 300px;
  
    /* Визначення висоти зображення *
    height: 300px;
  
    /* Додавання відступів до зображення *
    margin: 10px;
    padding: 10px;
  
    /* Заокруглення кутів зображення *
    border-radius: 2px;
  
    /* Розтягування фону зображення на весь елемент *
    background-size: cover;
  
    /* Обрізання фону зображення по межах елемента *
    background-clip: border-box;
  
    /* Застосування ефекту насиченості до зображення *
    filter: saturate(150%);
  
    /* Перехід від форми восьмикутника до кола при наведенні *
    transition: clip-path filter 1s;
  
    /* Обрізає зображення до форми восьмикутника *
    clip-path: polygon(
      /* Верхній правий кут *
      50% 0%,
  
      /* Верхня права сторона, відсунута ліворуч на 20% *
      80% 10%,
  
      /* Нижній правий кут, відсунутий вгору на 35% *
      100% 35%,
  
      /* Нижній правий кут *
      100% 70%,
  
      /* Нижня ліва сторона, відсунута праворуч на 20% *
      80% 90%,
  
      /* Нижній лівий кут *
      50% 100%,
  
      /* Верхня ліва сторона, відсунута праворуч на 20% *
      20% 90%,
  
      /* Верхній лівий кут *
      0% 70%,
      /* Верхня ліва сторона, відсунута вгору на 35% *
      0% 35%,
  
      /* Верхня ліва сторона, відсунута праворуч на 20% *
      20% 10%
    );
  }
  /*
  .clipPath:hover { *
    /* Застосовує ефект чорно-білого фото до зображення при наведенні *
    filter: grayscale(0%);
  
    /* Обрізає зображення до форми кола *
    clip-path: circle(30% at 50% 50%);
  }
/*


/* Домашнє завдання №36
Створіть CSS клас для DIV елементу,
який буде анімувати форму з кола радіусом 50%
до еліпсу з радіусами 25% та 50% при наведенні
курсору миші. Використайте властивість transition
для плавного переходу протягом 0.5 секунд. */

/* Визначення базових стилів елемента */
.clipPath {
    /* Ширина та висота елемента */
    width: 150px;
    height: 150px;
  
    /* Обрізання кутів до кола радіусом 50% */
    border-radius: 50%;
  
    /* Колір фону */
    background-color: lightblue;
  
    /* Властивість transition, яка визначає, 
    яка властивість буде анімована та протягом якого часу */
    transition: border-radius 0.5s;
  }
  
  /* Анімація форми при наведенні */
  .clipPath:hover {
    /* Обрізання кутів до еліпсу з радіусами 25% та 50% */
    border-radius: 25% 50%;
  }
  

  /*
  Домашне завдання Урок №38
  Напишіть CSS правило, яке дозволить виділяти текст
   лише для текстового контенту всередині елементів класу
    `.selectable-text`, але не для інших елементів, 
    таких як зображення чи іконки.
  */
  .selectable-text {
    /* Властивість `user-select` визначає, чи можна виділяти вміст елемента. Значення `text` дозволяє виділяти текст. */
    user-select: text;
  }

  /*
    Домашне завдання Урок №39
    Напишіть CSS клас `.custom-overflow`, який змусить текст переповнюватися 
    з контейнера і показати користувацький рядок "Читати далі...". Забезпечте, 
    що ви врахували всі необхідні умови, згадані у уроці.
  */

  .custom-overflow {
    /* Властивість `overflow` визначає, як браузер обробляє переповнення контенту. Значення `hidden` приховує переповнений контент. */
    overflow: hidden;
  
    /* Властивість `text-overflow` визначає, як браузер відображає переповнений текст. Значення `ellipsis` відображає три крапки (...), якщо текст не поміщається в контейнер. */
    text-overflow: ellipsis;
  
    /* Властивість `white-space` визначає, як браузер обробляє пробіли в тексті. Значення `nowrap` запобігає тому, щоб текст переносився на наступний рядок. */
    white-space: nowrap;
  
    /* Атрибут `data-custom-text` задає текст, який буде відображатися після переповнення. */
    data-custom-text: "Читати далі...";

    font-weight: bold;

  }
  

  
  
    

  

